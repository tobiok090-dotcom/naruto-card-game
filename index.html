<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ - Ù„Ø¹Ø¨Ø© Ù†Ø§Ø±ÙˆØªÙˆ</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
<style>
/* Ø¥Ø®ÙØ§Ø¡ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…ÙˆÙ‚Ø¹ ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© */
#content {
    display: none;
}
:root {
  --primary-color: #d42027;
  --secondary-color: #f5b316;
  --dark-color: #1a0d0f;
  --light-color: #f8f1e5;
  --accent-color: #007bff;
  --success-color: #28a745;
  --red-color: #dc3545; /* Added red color */
  --blue-color: #007bff; /* Added blue color */
  
  /* New Card Rarity Colors */
  --legendary-color: #FFD700; /* Gold */
  --rare-color: #C0C0C0; /* Silver */
  --common-color: #CD7F32; /* Bronze / Brownish-Red */
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Cairo', sans-serif;
  background-color: var(--dark-color);
  color: var(--light-color);
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center; /* Center content vertically */
  min-height: 100vh;
  position: relative;
  direction: rtl; /* Added for right-to-left alignment */
}

#resizable-bg {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    background: linear-gradient(to bottom, var(--dark-color), #2e0f15);
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><path fill="%23d42027" opacity="0.1" d="M50,0 C77.614,0 100,22.386 100,50 C100,77.614 77.614,100 50,100 C22.386,100 0,77.614 0,50 C0,22.386 22.386,0 50,0 Z" /></svg>');
    background-size: 510px;
}

.content-wrapper {
    width: 100%;
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
}

.container {
  max-width: 1600px;
  width: 100%;
  margin: 0 auto;
}

header {
  text-align: center;
  margin-bottom: 30px;
  width: 100%;
}

header h1 {
  color: var(--secondary-color);
  font-size: 2.5rem;
  margin-bottom: 10px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

header p {
  font-size: 1.1rem;
  opacity: 0.9;
}

#round-counter {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.7);
  color: var(--light-color);
  padding: 10px 20px;
  border-radius: 10px;
  font-size: 1.2rem;
  font-weight: bold;
  z-index: 1000;
  border: 2px solid var(--secondary-color);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
}

h2, h3, h4 {
  margin: 15px 0;
  color: var(--secondary-color);
}

.deck-selection {
  max-width: 900px;
  width: 100%;
  text-align: center;
  background: rgba(26, 13, 15, 0.8);
  padding: 25px;
  border-radius: 15px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
  margin-bottom: 20px;
  border: 1px solid var(--primary-color);
}

.deck-container, #rounds-container1, #rounds-container2 {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 15px;
  margin-top: 15px;
}

.round-slot {
  width: 200px;
  height: 280px;
  border: 2px dashed var(--secondary-color);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  border-radius: 12px;
  position: relative;
  cursor: pointer;
  background: rgba(255, 255, 255, 0.05);
  transition: all 0.3s ease;
  overflow: hidden; /* New: To contain the border-bar */
}

.round-slot.selected {
  border: 3px solid var(--accent-color);
  transform: translateY(-5px);
  box-shadow: 0 5px 15px rgba(0, 123, 255, 0.5);
}

.round-slot:hover {
  transform: translateY(-5px);
  box-shadow: 0 5px 15px rgba(212, 32, 39, 0.4);
  border-color: var(--primary-color);
}

.round-slot span {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 3;
  font-weight: bold;
  font-size: 18px;
  color: var(--light-color);
  background: rgba(0, 0, 0, 0.3);
  border-radius: 10px;
}

.round-slot img {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  border-radius: 10px;
  cursor: pointer;
  z-index: 2;
  transition: opacity 0.3s ease, filter 0.5s ease;
}

.round-slot.loading img {
  opacity: 0.5;
}

.round-slot.loading::after {
  content: "Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: var(--light-color);
  font-weight: bold;
  z-index: 4;
}

/* New: Rarity Border Bar */
.round-slot::before {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    height: 100%;
    width: 8px; /* Width of the border bar */
    z-index: 5;
    background-color: transparent; /* Default */
    border-radius: 0 10px 10px 0;
    transition: background-color 0.3s ease; /* Added transition */
}

.round-slot[data-rarity="Legendary"]::before {
    background-color: var(--legendary-color);
}

.round-slot[data-rarity="Rare"]::before {
    background-color: var(--rare-color);
}

.round-slot[data-rarity="Common"]::before {
    background-color: var(--common-color);
}

/* New: Hide rarity bar when fog is applied to the image */
.round-slot.card-foggy-active::before {
    background-color: transparent !important;
}


.card-actions {
    position: absolute;
    bottom: 5px;
    left: 5px;
    z-index: 4;
    display: flex;
    gap: 5px;
}

.card-actions label {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 30px;
    height: 30px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    border-radius: 50%;
    cursor: pointer;
    transition: background 0.2s ease;
}

.card-actions label:hover {
    background: rgba(0, 0, 0, 0.9);
}

input[type="text"], input[type="number"], textarea, input[type="password"] {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--secondary-color);
  border-radius: 8px;
  padding: 10px;
  color: var(--light-color);
  font-family: 'Cairo', sans-serif;
  margin: 5px 0;
  width: 100%;
  max-width: 300px;
  direction: rtl; /* Default for Arabic text */
}

/* FIX: Force LTR for notes */
textarea#notes1, textarea#notes2 {
  direction: ltr !important;
  text-align: left;
}


input[type="file"] {
    max-width: 100%;
}

input[type="text"]:focus, input[type="number"]:focus, textarea:focus, input[type="password"]:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 5px var(--primary-color);
}

label {
  display: block;
  margin: 10px 0;
  font-weight: bold;
}

button.main {
  margin-top: 15px;
  padding: 12px 25px;
  border: none;
  border-radius: 8px;
  background: linear-gradient(to bottom, var(--primary-color), #a00);
  color: var(--light-color);
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);
}

button.main:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 10px rgba(0, 0, 0, 0.4);
  background: linear-gradient(to bottom, #e53b42, #b00);
}

button.main:active {
  transform: translateY(0);
  box-shadow: 2px 3px rgba(0, 0, 0, 0.3);
}

/* Battle Interface Styles */

#match {
  display: none;
  flex-direction: column;
  align-items: center;
  width: 100%;
  margin-top: 20px;
}

.players-container {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  gap: 30px;
  width: 100%;
  flex-wrap: wrap;
}

.player {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 750px;
  background: rgba(26, 13, 15, 0.8);
  padding: 20px;
  border-radius: 15px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
  border: 1px solid var(--primary-color);
  text-align: center;
}

.player-name {
  font-size: 24px;
  font-weight: bold;
  margin-bottom: 15px;
  color: var(--secondary-color);
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
}

.card-and-abilities {
  display: flex;
  align-items: center;
  gap: 20px;
  width: 100%;
}

.abilities-container-side {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  width: 250px;
  flex-shrink: 0;
}

.ability-wrapper {
  background: rgba(0, 0, 0, 0.3);
  padding: 10px;
  border-radius: 10px;
  border: 1px solid var(--secondary-color);
  width: 100%;
  text-align: center;
}

.previous-card-container {
  min-height: 200px;
  width: 100%;
  border: 2px dashed #555;
  border-radius: 10px;
  margin-bottom: 15px;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
  background: rgba(255, 255, 255, 0.05);
}

.previous-card-container img {
  max-width: 100%;
  max-height: 80%;
  object-fit: contain;
  border-radius: 8px;
  opacity: 0.7;
}

.card {
  flex-grow: 1;
  width: 450px;
  height: 600px;
  border-radius: 12px;
  background: #222;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  cursor: pointer;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
  border: 2px solid var(--secondary-color);
  transition: all 0.3s ease;
  position: relative; /* Added for rarity bar */
}

.card img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  transition: transform 0.3s ease, filter 0.5s ease;
}

.card:hover img {
  transform: scale(1.05);
}

/* New: Rarity Border Bar for currently played card */
.card::before {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    height: 100%;
    width: 8px; /* Width of the border bar */
    z-index: 5;
    background-color: transparent; /* Default */
    border-radius: 0 10px 10px 0;
    transition: background-color 0.3s ease;
}

.card[data-rarity="Legendary"]::before {
    background-color: var(--legendary-color);
}

.card[data-rarity="Rare"]::before {
    background-color: var(--rare-color);
}

.card[data-rarity="Common"]::before {
    background-color: var(--common-color);
}

/* New: Hide rarity bar when card image is foggy */
.card.card-foggy-active::before {
    background-color: transparent !important;
}


/* New foggy class for cards only */
.card-foggy {
    filter: blur(20px) brightness(0.3);
}

.hp-control {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 15px;
}

.hp-control .buttons {
  display: flex;
  justify-content: center;
  width: 100%;
}

.hp-control input {
  width: 80px;
  text-align: center;
  font-size: 20px;
  border-radius: 8px;
  border: 2px solid var(--primary-color);
  padding: 5px;
  margin: 8px 0;
  font-weight: bold;
  background: rgba(0, 0, 0, 0.3);
  color: var(--light-color);
}

.hp-control button {
  margin: 5px;
  padding: 8px 15px;
  cursor: pointer;
  border: none;
  border-radius: 8px;
  font-weight: bold;
  transition: 0.2s;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.hp-control button.plus {
  background: var(--success-color);
  color: var(--light-color);
}
.hp-control button.minus {
  background: var(--primary-color);
  color: var(--light-color);
}

.hp-control button:hover.plus {
  background: #218838;
}
.hp-control button:hover.minus {
  background: #ff2222;
}

.hp-control button:hover {
  transform: translateY(-2px);
}

.player-notes-container {
    display: flex;
    justify-content: space-between;
    gap: 20px;
    width: 100%;
    margin-top: 20px;
    flex-wrap: wrap;
}

.player-notes {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: calc(50% - 10px);
  padding: 15px;
  background: rgba(26, 13, 15, 0.8);
  border-radius: 15px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
  border: 1px solid var(--primary-color);
}

.player-notes label {
  font-weight: bold;
  margin-bottom: 5px;
}

.player-notes textarea {
  font-size: 18px;
  font-family: 'Cairo', sans-serif, 'Arial', sans-serif;
  border-radius: 8px;
  padding: 10px;
  width: 100%;
  min-height: 100px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--secondary-color);
  color: var(--light-color);
  margin-top: 10px;
  resize: vertical;
}

.note-shortcuts {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 8px;
  margin-top: 10px;
  width: 100%;
}

.note-shortcut {
  padding: 8px 12px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.2s ease;
  background: #555;
  color: white;
}
.note-shortcut:hover {
  background: #777;
}

.note-shortcut.active {
  background: var(--accent-color);
  color: var(--light-color);
}

/* Styles for note shortcut colors */
.note-shortcut.red {
    background-color: var(--red-color);
}
.note-shortcut.green {
    background-color: var(--success-color);
}
.note-shortcut.blue {
    background-color: var(--blue-color);
}

.player-abilities {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 15px;
  width: 100%;
}

.abilities-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 10px;
  margin-top: 10px;
  width: 100%;
}

.ability {
  /* Ø­Ø¬Ù… Ø«Ø§Ø¨Øª Ù„Ù„Ù‚Ø¯Ø±Ø§Øª */
  width: 100%;
  height: 60px; /* Ø§Ø±ØªÙØ§Ø¹ Ø«Ø§Ø¨Øª */
  min-height: 60px;
  max-height: 60px;
  
  /* Ø§Ù„Ù…Ø­ØªÙˆÙ‰ ÙˆØ§Ù„Ù†Øµ */
  padding: 8px;
  background: linear-gradient(to bottom, var(--secondary-color), #d99c00);
  color: var(--dark-color);
  border-radius: 12px;
  cursor: pointer;
  user-select: none;
  font-weight: bold;
  text-align: center;
  transition: all 0.3s ease;
  border: 2px solid var(--dark-color);
  margin: 4px 0;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  
  /* ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù†Øµ Ù„Ù„Ø­Ø¬Ù… Ø§Ù„Ø«Ø§Ø¨Øª */
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  line-height: 1.2;
  overflow: hidden;
  word-wrap: break-word;
  hyphens: auto;
}

.ability:hover {
  transform: translateY(-3px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
}

.ability.used {
  background: linear-gradient(to bottom, #cc6600, #994d00);
  color: var(--light-color);
  border: 2px solid var(--dark-color);
  opacity: 0.7;
}

/* ØªØµØºÙŠØ± Ø§Ù„Ù†Øµ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ù„Ù„Ù†ØµÙˆØµ Ø§Ù„Ø·ÙˆÙŠÙ„Ø© */
.ability.long-text {
  font-size: 12px;
}

.ability.very-long-text {
  font-size: 10px;
}

.ability.extremely-long-text {
  font-size: 9px;
  line-height: 1.1;
}

.add-ability {
  margin-top: 15px;
  display: flex;
  gap: 10px;
  width: 100%;
  max-width: 300px;
}

.add-ability input {
  flex: 1;
  padding: 10px;
  border-radius: 8px;
  border: 1px solid var(--secondary-color);
  background: rgba(255, 255, 255, 0.1);
  color: var(--light-color);
  font-family: 'Cairo', sans-serif;
}

.add-ability button {
  padding: 10px 15px;
  border: none;
  border-radius: 8px;
  background: var(--success-color);
  color: var(--light-color);
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s ease;
}

.add-ability button:hover {
  background: #218838;
  transform: translateY(-2px);
}

#navigation {
  margin-top: 20px;
  display: none;
  gap: 15px;
  flex-wrap: wrap;
  justify-content: center;
}

#zoom-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.95);
  justify-content: center;
  align-items: center;
  z-index: 9999;
  cursor: pointer;
  flex-direction: column;
}

#zoom-modal img {
  max-width: 95%;
  max-height: 95%;
  border-radius: 10px;
  box-shadow: 0 0 30px var(--primary-color);
  border: 2px solid var(--secondary-color);
}

.transparency-control {
    position: absolute;
    bottom: 20px;
    right: 20px;
    display: none;
    align-items: center;
    gap: 10px;
    background: rgba(26, 13, 15, 0.7);
    padding: 10px 15px;
    border-radius: 20px;
    border: 1px solid var(--secondary-color);
    z-index: 10000;
}

.transparency-control label {
    font-size: 1rem;
    color: var(--light-color);
}

#transparency-slider {
    width: 120px;
    height: 6px;
    -webkit-appearance: none;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
    outline: none;
}

#transparency-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--secondary-color);
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
}

#transparency-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--secondary-color);
    cursor: pointer;
    border: none;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
}

.loading-spinner {
  display: inline-block;
  width: 20px;
  height: 20px;
  border: 3px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  border-top-color: var(--light-color);
  animation: spin 1s ease-in-out infinite;
  margin-right: 10px;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.status-message {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--success-color);
  color: white;
  padding: 10px 20px;
  border-radius: 5px;
  z-index: 10001;
  box-shadow: 0 3px 10px rgba(0,0,0,0.2);
  display: none;
}
.player-notes.right {
  order: 2;
}

.player-notes.left {
  order: 1;
}

.file-control {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 15px;
}

.file-control label.main {
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    color: var(--light-color);
    background: linear-gradient(to bottom, var(--primary-color), #a00);
    padding: 12px 25px;
    border-radius: 8px;
    box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
    border: none;
    margin: 15px 0 0 0;
}
.file-control label.main:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.4);
    background: linear-gradient(to bottom, #e53b42, #b00);
}
.file-control label.main:active {
    transform: translateY(0);
    box-shadow: 2px 3px rgba(0, 0, 0, 0.3);
}

/* Audio Controls Styles */
#audio-controls {
    position: fixed;
    top: 20px;
    right: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
    background: rgba(26, 13, 15, 0.9);
    padding: 10px 15px;
    border-radius: 25px;
    border: 2px solid var(--secondary-color);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    z-index: 1000;
}

#mute-btn {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    padding: 5px;
    border-radius: 50%;
    transition: all 0.3s ease;
    color: var(--light-color);
}

#mute-btn:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: scale(1.1);
}

#mute-btn.muted {
    color: var(--primary-color);
}

#volume-slider {
    width: 80px;
    height: 5px;
    border-radius: 5px;
    background: rgba(255, 255, 255, 0.2);
    outline: none;
    cursor: pointer;
}

#volume-slider::-webkit-slider-thumb {
    appearance: none;
    width: 15px;
    height: 15px;
    border-radius: 50%;
    background: var(--secondary-color);
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
}

#volume-slider::-moz-range-thumb {
    width: 15px;
    height: 15px;
    border-radius: 50%;
    background: var(--secondary-color);
    cursor: pointer;
    border: none;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
}

.card-audio-indicator {
    position: absolute;
    top: 5px;
    right: 5px;
    background: var(--secondary-color);
    color: var(--dark-color);
    border-radius: 50%;
    width: 25px;
    height: 25px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: bold;
    z-index: 10;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.card:hover .card-audio-indicator {
    opacity: 1;
}

#bg-music-upload {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 1000;
}

#fullscreen-btn {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    padding: 5px;
    border-radius: 50%;
    transition: all 0.3s ease;
    color: var(--light-color);
}
#fullscreen-btn:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: scale(1.1);
}
#fullscreen-icon {
    display: inline-block;
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
}

/* New CSS for ATK, DEF, and ROUND stats */
.card-stats {
  display: flex;
  justify-content: center;
  gap: 8px;
  margin: 10px 0;
  width: 100%;
  align-items: flex-end;
}

.card-stats .stat-group {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.card-stats .stat-group label {
  font-size: 0.9rem;
  font-weight: bold;
  margin: 0;
  color: var(--secondary-color);
}

.card-stats .stat-group input {
  width: 50px;
  text-align: center;
  font-size: 16px;
  border-radius: 8px;
  border: 1px solid var(--secondary-color);
  padding: 4px;
  margin-top: 3px;
  background: rgba(0, 0, 0, 0.3);
  color: var(--light-color);
}

.card-stats .reset-button {
  padding: 4px 8px;
  font-size: 12px;
  font-weight: bold;
  border: none;
  border-radius: 8px;
  background: var(--primary-color);
  color: var(--light-color);
  cursor: pointer;
  transition: all 0.3s ease;
  height: 32px;
}

.card-stats .reset-button:hover {
  background: #e53b42;
  transform: translateY(-2px);
}

.card-stats .reset-button:active {
  transform: translateY(0);
}

/* Styles for login page */
#login-page {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  max-width: 500px;
  width: 100%;
  padding: 40px;
  background: rgba(26, 13, 15, 0.8);
  border-radius: 20px;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
  border: 2px solid var(--secondary-color);
  text-align: center;
  animation: fadeIn 1s ease-in-out;
}

#login-page h1 {
  font-size: 3.5rem;
  color: var(--primary-color);
  text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.7);
  margin-bottom: 20px;
}

#login-page .input-group {
  margin-bottom: 20px;
  width: 100%;
}

#login-page .input-group label {
  display: block;
  font-size: 1.2rem;
  font-weight: bold;
  color: var(--light-color);
  margin-bottom: 5px;
}

#login-page .input-group input {
  width: 100%;
  max-width: 300px;
  padding: 12px;
  font-size: 1.1rem;
  border-radius: 10px;
  border: 1px solid var(--secondary-color);
  background: rgba(255, 255, 255, 0.05);
  color: var(--light-color);
}

#login-message {
  color: var(--red-color);
  font-weight: bold;
  margin-top: 15px;
  display: none;
}
</style>
<script>
    // Ø¨ÙŠØ§Ù†Ø§Øª ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„ØµØ­ÙŠØ­Ø©
    const correctUsername = "naruto-card-clash";
    const correctPassword = "katsuki123";

    function validateLogin() {
        const usernameInput = document.getElementById("username-input").value;
        const passwordInput = document.getElementById("password-input").value;
        const loginMessage = document.getElementById("login-message");

        if (usernameInput === correctUsername && passwordInput === correctPassword) {
            document.getElementById("login-page").style.display = "none";
            document.getElementById("content").style.display = "flex";
            document.title = "Ù…Ø¹Ø±ÙƒØ© Ù†Ø§Ø±ÙˆØªÙˆ - Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª";
            playBackgroundMusic();
        } else {
            loginMessage.textContent = "Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø± ØºÙŠØ± ØµØ­ÙŠØ­Ø©.";
            loginMessage.style.display = "block";
        }
    }
</script>
</head>
<body>

    <div id="login-page">
        <h1>Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙÙŠ Ù„Ø¹Ø¨Ø© Ù†Ø§Ø±ÙˆØªÙˆ Ù„Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</h1>
        <div class="input-group">
            <label for="username-input">Username:</label>
            <input type="text" id="username-input" placeholder="Ø£Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…">
        </div>
        <div class="input-group">
            <label for="password-input">Password:</label>
            <input type="password" id="password-input" placeholder="Ø£Ø¯Ø®Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø±">
        </div>
        <button class="main" id="login-btn">Continue</button>
        <span id="login-message"></span>
    </div>

    <div id="content">
        <div id="resizable-bg"></div>

        <div class="content-wrapper">
          <div class="container">
            <header>
              <h1>Ù…Ø¹Ø±ÙƒØ© Ù†Ø§Ø±ÙˆØªÙˆ - Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</h1>
              <p>Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª ÙˆØ§Ø¨Ø¯Ø£ Ø§Ù„Ù…Ø¹Ø±ÙƒØ©!</p>
              <div id="round-counter" style="display:none;"></div>
            </header>

            <div id="bg-music-upload">
              <label class="main">
                ØªØ­Ù…ÙŠÙ„ Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø§Ù„Ø®Ù„ÙÙŠØ©
                <input type="file" id="bg-music-file" accept="audio/*" style="display:none;">
              </label>
            </div>

            <div id="player1-interface" class="deck-selection">
              <h2>âš Deck Ø§Ù„Ù„Ø§Ø¹Ø¨ 1</h2>
              <label>Ø¹Ù†ÙˆØ§Ù† Deck Ø§Ù„Ù„Ø§Ø¹Ø¨ 1: <input type="text" id="title1" placeholder="Ù…Ø«Ù„Ø§Ù‹ ÙØ±ÙŠÙ‚ Ø§Ù„Ù†Ø§Ø±"></label>
              
              <button class="main" onclick="drawRandomDeck(1)">ğŸ² Ø³Ø­Ø¨ Ø¨Ø·Ø§Ù‚Ø§Øª Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© (1 Ø£Ø³Ø·ÙˆØ±ÙŠØ© + 5 Ù†Ø§Ø¯Ø±Ø© + 5 Ø¹Ø§Ø¯ÙŠØ©)</button>

              <button class="main" onclick="drawPlayerAbilities(1)">ğŸ”¥ Ø³Ø­Ø¨ Ø§Ù„Ù‚Ø¯Ø±Ø§Øª (3 Ù‚Ø¯Ø±Ø§Øª)</button> 
              <div class="abilities-container" id="deck1-abilities-display" style="margin-top: 15px; border: 1px dashed #f5b316; padding: 10px; border-radius: 10px; min-height: 80px;">
                  <p style="opacity: 0.8;">Ø³ØªØ¸Ù‡Ø± Ù‚Ø¯Ø±Ø§ØªÙƒ Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ Ø§Ù„Ø³Ø­Ø¨...</p>
              </div>
              
              <h3>Ø§Ù„Ø¬ÙˆÙ„Ø§Øª (1-11)</h3>
              <div id="rounds-container1"></div>

              <div class="file-control">
                  <button class="main" onclick="exportPlayerData(1)">ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù„Ø§Ø¹Ø¨ 1</button>
                  <label class="main">
                      Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù„Ø§Ø¹Ø¨ 1
                      <input type="file" id="import-file-1" accept=".json" style="display:none;" onchange="importPlayerData(event, 1)">
                  </label>
              </div>
              
              <button class="main" onclick="toggleFogEffect()">ØªÙØ¹ÙŠÙ„ / Ø¥Ù„ØºØ§Ø¡ Ø¶Ø¨Ø§Ø¨ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</button>
              <button class="main" id="next-to-player2">Ø§Ù„ØªØ§Ù„ÙŠ: Ù„Ø§Ø¹Ø¨ 2 â†’</button>
            </div>

            <div id="player2-interface" class="deck-selection" style="display:none;">
              <h2>âš Deck Ø§Ù„Ù„Ø§Ø¹Ø¨ 2</h2>
              <label>Ø¹Ù†ÙˆØ§Ù† Deck Ø§Ù„Ù„Ø§Ø¹Ø¨ 2: <input type="text" id="title2" placeholder="Ù…Ø«Ù„Ø§Ù‹ ÙØ±ÙŠÙ‚ Ø§Ù„Ø±ÙŠØ§Ø­"></label>
              
              <button class="main" onclick="drawRandomDeck(2)">ğŸ² Ø³Ø­Ø¨ Ø¨Ø·Ø§Ù‚Ø§Øª Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© (1 Ø£Ø³Ø·ÙˆØ±ÙŠØ© + 5 Ù†Ø§Ø¯Ø±Ø© + 5 Ø¹Ø§Ø¯ÙŠØ©)</button>
              
              <button class="main" onclick="drawPlayerAbilities(2)">ğŸ”¥ Ø³Ø­Ø¨ Ø§Ù„Ù‚Ø¯Ø±Ø§Øª (3 Ù‚Ø¯Ø±Ø§Øª)</button>
              <div class="abilities-container" id="deck2-abilities-display" style="margin-top: 15px; border: 1px dashed #f5b316; padding: 10px; border-radius: 10px; min-height: 80px;">
                  <p style="opacity: 0.8;">Ø³ØªØ¸Ù‡Ø± Ù‚Ø¯Ø±Ø§ØªÙƒ Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ Ø§Ù„Ø³Ø­Ø¨...</p>
              </div>

              <h3>Ø§Ù„Ø¬ÙˆÙ„Ø§Øª (1-11)</h3>
              <div id="rounds-container2"></div>
              
              <div class="file-control">
                  <button class="main" onclick="exportPlayerData(2)">ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù„Ø§Ø¹Ø¨ 2</button>
                  <label class="main">
                      Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù„Ø§Ø¹Ø¨ 2
                      <input type="file" id="import-file-2" accept=".json" style="display:none;" onchange="importPlayerData(event, 2)">
                  </label>
              </div>

              <button class="main" onclick="toggleFogEffect()">ØªÙØ¹ÙŠÙ„ / Ø¥Ù„ØºØ§Ø¡ Ø¶Ø¨Ø§Ø¨ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</button>
              <button class="main" id="back-to-player1">â† Ø¹ÙˆØ¯Ø©: Ù„Ø§Ø¹Ø¨ 1</button>
              <button class="main" id="start-game-btn">Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø¹Ø±ÙƒØ©!</button>
            </div>

            <div id="match" style="display:none;">
              <div class="players-container">
                <div class="player">
                  <div class="player-name" id="player1-title">Ø§Ù„Ù„Ø§Ø¹Ø¨ 1</div>
                  <div class="card-and-abilities">
                    <div class="abilities-container-side">
                      <div class="ability-wrapper">
                        <h4>Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©</h4>
                        <div class="previous-card-container">
                          <img id="previous-card1" src="">
                        </div>
                      </div>
                      <h4>Ø§Ù„Ù‚Ø¯Ø±Ø§Øª</h4>
                      <div class="abilities-container" id="player1-abilities"></div>
                      <div class="add-ability">
                        <input id="new-ability1" placeholder="Ø§ÙƒØªØ¨ Ù‚Ø¯Ø±Ø© Ø¬Ø¯ÙŠØ¯Ø©">
                        <button onclick="addAbility('player1')">Ø£Ø¶Ù</button>
                      </div>
                    </div>
                    <div>
                      <label>ØªØ­Ù…ÙŠÙ„ Ø¨Ø·Ø§Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø©:
                        <input type="file" accept="image/*" onchange="replaceCard(event, 1)">
                      </label>
                      <div class="card" id="player1-card">
                        <img id="card1" src="">
                      </div>
                      <div class="card-stats">
                          <div class="stat-group">
                              <label for="def1">DEF</label>
                              <input type="number" id="def1" min="0">
                          </div>
                          <div class="stat-group">
                              <label for="atk1">ATK</label>
                              <input type="number" id="atk1" min="0">
                          </div>
                          <div class="stat-group">
                              <label for="round1">Round</label>
                              <input type="number" id="round1" min="0">
                          </div>
                          <button class="reset-button" onclick="resetStats(1)">Reset</button>
                      </div>
                      <div class="hp-control">
                        <label>Ù†Ù‚Ø§Ø· Ø§Ù„ØµØ­Ø© (HP)</label>
                        <div class="buttons">
                          <button class="minus" onclick="changeHP(1, -1)">-</button>
                          <input type="number" id="hp1" value="11" min="0">
                          <button class="plus" onclick="changeHP(1, 1)">+</button>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="player">
                  <div class="player-name" id="player2-title">Ø§Ù„Ù„Ø§Ø¹Ø¨ 2</div>
                  <div class="card-and-abilities">
                    <div>
                      <label>ØªØ­Ù…ÙŠÙ„ Ø¨Ø·Ø§Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø©:
                        <input type="file" accept="image/*" onchange="replaceCard(event, 2)">  </label>
                      <div class="card" id="player2-card">
                        <img id="card2" src="">
                      </div>
                      <div class="card-stats">
                          <div class="stat-group">
                              <label for="def2">DEF</label>
                              <input type="number" id="def2" min="0">
                          </div>
                          <div class="stat-group">
                              <label for="atk2">ATK</label>
                              <input type="number" id="atk2" min="0">
                          </div>
                          <div class="stat-group">
                              <label for="round2">Round</label>
                              <input type="number" id="round2" min="0">
                          </div>
                          <button class="reset-button" onclick="resetStats(2)">Reset</button>
                      </div>
                      <div class="hp-control">
                        <label>Ù†Ù‚Ø§Ø· Ø§Ù„ØµØ­Ø© (HP)</label>
                        <div class="buttons">
                          <button class="minus" onclick="changeHP(2, -1)">-</button>
                          <input type="number" id="hp2" value="11" min="0">
                          <button class="plus" onclick="changeHP(2, 1)">+</button>
                        </div>
                      </div>
                    </div>
                    <div class="abilities-container-side">
                      <div class="ability-wrapper">
                        <h4>Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©</h4>
                        <div class="previous-card-container">
                          <img id="previous-card2" src="">
                        </div>
                      </div>
                      <h4>Ø§Ù„Ù‚Ø¯Ø±Ø§Øª</h4>
                      <div class="abilities-container" id="player2-abilities"></div>
                      <div class="add-ability">
                        <input id="new-ability2" placeholder="Ø§ÙƒØªØ¨ Ù‚Ø¯Ø±Ø© Ø¬Ø¯ÙŠØ¯Ø©">
                        <button onclick="addAbility('player2')">Ø£Ø¶Ù</button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="player-notes-container">
                <div class="player-notes left">
                  <label>Player Notes:</label>
                  <div class="note-shortcuts" id="shortcuts1">
                    </div>
                  <textarea id="notes1" rows="2" placeholder="Typing notes here..."></textarea>
                </div>
                <div class="player-notes right">
                  <label>Player Notes:</label>
                  <div class="note-shortcuts" id="shortcuts2">
                    </div>
                  <textarea id="notes2" rows="2" placeholder="Typing notes here..."></textarea>
                </div>
              </div>
            </div>

            <div id="navigation">
              <button class="main" onclick="prevRound()">â† Ø§Ù„Ø³Ø§Ø¨Ù‚</button>
              <button class="main" onclick="toggleFogEffect()">ØªÙØ¹ÙŠÙ„ / Ø¥Ù„ØºØ§Ø¡ Ø¶Ø¨Ø§Ø¨ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</button>
              <button class="main" onclick="nextRound()">Ø§Ù„ØªØ§Ù„ÙŠ â†’</button>
            </div>
            
            <div id="zoom-modal">
              <img id="zoom-img" src="">
              <div class="transparency-control">
                <label for="transparency-slider">Ø§Ù„Ø´ÙØ§ÙÙŠØ©:</label>
                <input type="range" id="transparency-slider" min="0" max="100" value="95">
              </div>
            </div>

            <div class="status-message" id="status-message"></div>
            
            <div id="audio-controls">
              <button id="mute-btn" title="ÙƒØªÙ…/Ø¥Ù„ØºØ§Ø¡ ÙƒØªÙ… Ø§Ù„ØµÙˆØª">ğŸ”Š</button>
              <input type="range" id="volume-slider" min="0" max="100" value="50" title="Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª">
              <button id="fullscreen-btn" title="Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø©">
                <span id="fullscreen-icon">â›¶</span>
              </button>
            </div>
            
            <audio id="background-music" loop></audio>
        </div>
    </div>

<script>
let backgroundMusic = null;
let cardSounds = {};
let isMuted = false;
let currentVolume = 0.5;
let clickTimeout;
let totalRounds = 11; 
let currentRound = 1;
let deck1 = [], deck2 = [];
let selectedSlot = null;
let previousCard1 = '', previousCard2 = '';
let globalDrawnCardsSet = new Set();
let deck1Abilities = []; 
let deck2Abilities = []; 

// New: Store notes globally
let playerNotes = {
    1: '',
    2: ''
};

// NEW: Store card stats globally for persistence
let cardStats = {
    1: { atk: '', def: '', round: '' },
    2: { atk: '', def: '', round: '' }
};

const noteShortcuts = [
  '+5 ATK', '-5 ATK', '+5 DEF', '-5 DEF', '+5 ATK/DEF', '-5 ATK/DEF', '+10 ATK', '-10 ATK', '+10 DEF', '-10 DEF', 'NEXT'
];

function initAudioSystem() {
    backgroundMusic = document.getElementById('background-music');
    const muteBtn = document.getElementById('mute-btn');
    const volumeSlider = document.getElementById('volume-slider');
    const bgMusicFile = document.getElementById('bg-music-file');

    bgMusicFile.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(event) {
                backgroundMusic.src = event.target.result;
                showStatus('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø§Ù„Ø®Ù„ÙÙŠØ© Ø¨Ù†Ø¬Ø§Ø­.');
                playBackgroundMusic();
            };
            reader.readAsDataURL(file);
        }
    });
    
    if (backgroundMusic) {
        backgroundMusic.volume = currentVolume;
    }
    
    muteBtn.addEventListener('click', () => {
        isMuted = !isMuted;
        if (backgroundMusic) {
            backgroundMusic.muted = isMuted;
        }
        muteBtn.textContent = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
        muteBtn.classList.toggle('muted', isMuted);
        
        showStatus(isMuted ? 'ØªÙ… ÙƒØªÙ… Ø§Ù„ØµÙˆØª' : 'ØªÙ… Ø¥Ù„ØºØ§Ø¡ ÙƒØªÙ… Ø§Ù„ØµÙˆØª');
    });
    
    volumeSlider.addEventListener('input', (e) => {
        currentVolume = e.target.value / 100;
        if (backgroundMusic) {
            backgroundMusic.volume = currentVolume;
        }
        Object.values(cardSounds).forEach(audio => {
            if (audio) audio.volume = currentVolume;
        });
    });
}

function playBackgroundMusic() {
    if (backgroundMusic && !isMuted) {
        backgroundMusic.currentTime = 0;
        const playPromise = backgroundMusic.play();
        if (playPromise !== undefined) {
            playPromise.catch(error => {
                console.log('Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø§Ù„Ø®Ù„ÙÙŠØ©:', error);
            });
        }
    }
}

function stopBackgroundMusic() {
    if (backgroundMusic) {
        backgroundMusic.pause();
        backgroundMusic.currentTime = 0;
    }
}

function addSoundToCard(cardIndex, audioFile, player) {
    const key = `${player}_${cardIndex}`;
    if (audioFile && audioFile.size > 0) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const audioDataUrl = e.target.result;
            if (player === 1) {
                deck1[cardIndex].sound = audioDataUrl;
            } else {
                deck2[cardIndex].sound = audioDataUrl;
            }
            
            showStatus(`ØªÙ… Ø¥Ø¶Ø§ÙØ© ØµÙˆØª Ù„Ù„Ø¨Ø·Ø§Ù‚Ø© ${cardIndex + 1} - Ø§Ù„Ù„Ø§Ø¹Ø¨ ${player}`);
        };
        reader.readAsDataURL(audioFile);
    }
}

function playCardSound(cardIndex, player) {
    return new Promise((resolve, reject) => {
        const deck = player === 1 ? deck1 : deck2;
        const cardData = deck[cardIndex];
        if (cardData && cardData.sound && !isMuted) {
            const audio = new Audio(cardData.sound);
            audio.volume = currentVolume;
            audio.currentTime = 0;
            audio.onended = () => resolve(); 
            audio.onerror = () => reject(new Error("Audio playback error")); 
            
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.log('Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©:', error);
                    reject(error);
                });
            }
        } else {
            resolve(); 
        }
    });
}
// SENSITIVE TO FOG STATE
function isFogEnabled() {
    const card1Img = document.getElementById('card1');
    const firstSlotImg = document.querySelector('.round-slot img'); 
    
    // Check if the card image or any of the deck slot images have the foggy class
    return (card1Img && card1Img.classList.contains('card-foggy')) || 
           (firstSlotImg && firstSlotImg.classList.contains('card-foggy'));
}

function Card(image, sound, rarity) {
    this.image = image;
    this.sound = sound;
    this.rarity = rarity || 'Common'; // New: Store rarity
}

function createRoundSlots(containerId, deck) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    const fogIsActive = isFogEnabled();

    // Ensure the deck array has the correct size and default values
    for (let i = 0; i < totalRounds; i++) {
        // Initialize deck element if it doesn't exist
        if (!deck[i]) {
            deck[i] = new Card('images/back.png', null, 'Common'); 
        }
        
        const slot = document.createElement('div');
        slot.className = 'round-slot';
        slot.setAttribute('data-round', i + 1);
        slot.setAttribute('data-index', i);
        slot.setAttribute('data-rarity', deck[i].rarity); // Set default rarity

        // Apply fog class to the slot container if fog is active
        if (fogIsActive) {
            slot.classList.add('card-foggy-active');
        }

        const span = document.createElement('span');
        span.textContent = i + 1;
        slot.appendChild(span);

        const img = document.createElement('img');
        img.src = deck[i].image;
        if (fogIsActive) {
            img.classList.add('card-foggy');
        }
        slot.appendChild(img);
        
        const cardActions = document.createElement('div');
        cardActions.className = 'card-actions';

        const audioLabel = document.createElement('label');
        audioLabel.textContent = 'ğŸ”Š';
        audioLabel.htmlFor = `card-audio-${containerId.includes('1') ? 1 : 2}-${i}`;

        const audioInput = document.createElement('input');
        audioInput.type = 'file';
        audioInput.id = `card-audio-${containerId.includes('1') ? 1 : 2}-${i}`;
        audioInput.accept = 'audio/*';
        audioInput.style.display = 'none';
        
        audioInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            const player = containerId.includes('1') ? 1 : 2;
            addSoundToCard(i, file, player);
        });

        cardActions.appendChild(audioLabel);
        cardActions.appendChild(audioInput);
        slot.appendChild(cardActions);

        container.appendChild(slot);
        
        setupSlotEvents(slot);
    }
}

document.getElementById('next-to-player2').addEventListener('click', () => {
  document.getElementById('player1-interface').style.display = 'none';
  document.getElementById('player2-interface').style.display = 'block';
  playBackgroundMusic();
});

document.getElementById('back-to-player1').addEventListener('click', () => {
  document.getElementById('player1-interface').style.display = 'block';
  document.getElementById('player2-interface').style.display = 'none';
  playBackgroundMusic();
});

function setupSlotEvents(slot) {
  const containerId = slot.parentElement.id;
  const index = parseInt(slot.getAttribute('data-index'));

  slot.addEventListener('mousedown', (e) => {
    clearTimeout(clickTimeout);
    clickTimeout = setTimeout(() => {
      const deck = containerId.includes('1') ? deck1 : deck2;
      const allSlots = document.getElementById(containerId).querySelectorAll('.round-slot');
      
      if (!selectedSlot) {
        selectedSlot = { containerId, index };
        slot.classList.add('selected');
      } else {
        if (selectedSlot.containerId === containerId) {
          const tempCard = deck[selectedSlot.index];
          deck[selectedSlot.index] = deck[index];
          deck[index] = tempCard;

          const img1 = allSlots[selectedSlot.index].querySelector('img');
          const img2 = allSlots[index].querySelector('img');
          
          const slot1 = allSlots[selectedSlot.index];
          const slot2 = allSlots[index];
          
          // Swap images
          if (img1) img1.src = deck[selectedSlot.index].image;
          if (img2) img2.src = deck[index].image;
          
          // Swap rarity attributes
          slot1.setAttribute('data-rarity', deck[selectedSlot.index].rarity);
          slot2.setAttribute('data-rarity', deck[index].rarity);
          
          // Clear selection
          allSlots.forEach(s => s.classList.remove('selected'));
          selectedSlot = null;
        } else {
          allSlots.forEach(s => s.classList.remove('selected'));
          selectedSlot = null;
        }
      }
    }, 200);
  });
  
  slot.addEventListener('dblclick', (e) => {
      clearTimeout(clickTimeout);
      const img = slot.querySelector('img');
      if (img && img.src && img.src.includes('data:image') || img.src.includes('http')) {
          showZoomModal(img.src);
      }
  });
}

// NEW: Save card stats to global state
function saveCardStats() {
    cardStats[1].atk = document.getElementById('atk1').value;
    cardStats[1].def = document.getElementById('def1').value;
    cardStats[1].round = document.getElementById('round1').value;
    
    cardStats[2].atk = document.getElementById('atk2').value;
    cardStats[2].def = document.getElementById('def2').value;
    cardStats[2].round = document.getElementById('round2').value;
}

// NEW: Load card stats from global state
function loadCardStats() {
    document.getElementById('atk1').value = cardStats[1].atk;
    document.getElementById('def1').value = cardStats[1].def;
    document.getElementById('round1').value = cardStats[1].round;
    
    document.getElementById('atk2').value = cardStats[2].atk;
    document.getElementById('def2').value = cardStats[2].def;
    document.getElementById('round2').value = cardStats[2].round;
}

function initializeStats() {
    // Clear global stats on new game
    cardStats[1] = { atk: '', def: '', round: '' };
    cardStats[2] = { atk: '', def: '', round: '' };
    
    document.getElementById('atk1').value = '';
    document.getElementById('def1').value = '';
    document.getElementById('round1').value = '';
    document.getElementById('atk2').value = '';
    document.getElementById('def2').value = '';
    document.getElementById('round2').value = '';
}

// New: Function to save notes state
function saveNotes() {
    playerNotes[1] = document.getElementById('notes1').value;
    playerNotes[2] = document.getElementById('notes2').value;
    document.querySelectorAll('.note-shortcut').forEach(btn => btn.classList.remove('active', 'green', 'red', 'blue'));
}

// New: Function to load notes state
function loadNotes() {
    const notes1 = document.getElementById('notes1');
    const notes2 = document.getElementById('notes2');
    
    notes1.value = playerNotes[1];
    notes2.value = playerNotes[2];
    
    // Re-highlight shortcuts based on current notes
    highlightShortcuts(1);
    highlightShortcuts(2);
}

function highlightShortcuts(player) {
    const notesTextarea = document.getElementById(`notes${player}`);
    let notesArray = notesTextarea.value.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    const containerId = player === 1 ? 'shortcuts1' : 'shortcuts2';
    
    document.getElementById(containerId).querySelectorAll('.note-shortcut').forEach(btn => {
        const text = btn.textContent;
        btn.classList.remove('active', 'green', 'red', 'blue');
        
        if (notesArray.includes(text)) {
            btn.classList.add('active');
            if (text.includes('+')) {
              btn.classList.add('green');
            } else if (text.includes('-')) {
              btn.classList.add('red');
            } else if (text.includes('NEXT')) {
              btn.classList.add('blue');
            }
        }
    });
}

async function loadRound(round) {
    // Save current notes and stats before changing round
    saveNotes();
    saveCardStats();

    currentRound = round;
    document.getElementById('round-counter').textContent = `Ø§Ù„Ø¬ÙˆÙ„Ø© ${round} / ${totalRounds}`;
    
    if (round === 1) {
        // Preserve current HP if loading a file, otherwise reset for a fresh game
        // We will rely on the imported data to set HP if a file was loaded
        
        // Only reset HP if it's the very start of a new, non-imported game state (optional, can be debated)
        // For simplicity and to allow imported HP to persist: do NOT reset HP here unless absolutely necessary.
        // If coming from deck selection, it's generally a new game, so HP should start at 11, unless importing.
        
        // We can check if we are returning from a game (i.e., not a fresh start after full reload/login)
        if (!document.getElementById('match').style.display) {
            document.getElementById('hp1').value = 11;
            document.getElementById('hp2').value = 11;
        }
        
        initializeStats();
        // Clear notes when starting a brand new game
        playerNotes[1] = '';
        playerNotes[2] = '';
    }
    
    // Load notes and stats for the current round
    loadNotes();
    loadCardStats();
    
    if (currentRound > 1) {
      previousCard1 = deck1[currentRound - 2].image;
      previousCard2 = deck2[currentRound - 2].image;
    } else {
      previousCard1 = '';
      previousCard2 = '';
    }
  
    document.getElementById('previous-card1').src = previousCard1 || 'images/back.png';
    document.getElementById('previous-card2').src = previousCard2 || 'images/back.png';
    
    const card1Img = document.getElementById('card1');
    const card2Img = document.getElementById('card2');
    const card1Element = document.getElementById('player1-card');
    const card2Element = document.getElementById('player2-card');
    const deck1Card = deck1[round - 1];
    const deck2Card = deck2[round - 1];
    
    card1Img.src = (deck1Card && deck1Card.image) || 'images/back.png';
    card2Img.src = (deck2Card && deck2Card.image) || 'images/back.png';
    
    // Set rarity on the card element
    card1Element.setAttribute('data-rarity', (deck1Card && deck1Card.rarity) || 'Common');
    card2Element.setAttribute('data-rarity', (deck2Card && deck2Card.rarity) || 'Common');

    // Apply fog if enabled
    const fogEnabled = isFogEnabled();
    card1Img.classList.toggle('card-foggy', fogEnabled);
    card2Img.classList.toggle('card-foggy', fogEnabled);
    
    // New: Handle rarity bar visibility when foggy for the current cards
    card1Element.classList.toggle('card-foggy-active', fogEnabled);
    card2Element.classList.toggle('card-foggy-active', fogEnabled);

    document.querySelector('title').textContent = `Ù…Ø¹Ø±ÙƒØ© Ù†Ø§Ø±ÙˆØªÙˆ - Ø§Ù„Ø¬ÙˆÙ„Ø© ${round}`;

    await playCardSound(round - 1, 1);
    await playCardSound(round - 1, 2);
}

document.getElementById('start-game-btn').addEventListener('click', () => {
  const title1 = document.getElementById('title1').value || 'Ø§Ù„Ù„Ø§Ø¹Ø¨ 1';
  const title2 = document.getElementById('title2').value || 'Ø§Ù„Ù„Ø§Ø¹Ø¨ 2';
  document.getElementById('player1-title').textContent = title1;
  document.getElementById('player2-title').textContent = title2;
  
  document.getElementById('player1-interface').style.display = 'none';
  document.getElementById('player2-interface').style.display = 'none';

  document.getElementById('match').style.display = 'flex';
  document.getElementById('navigation').style.display = 'flex';
  document.getElementById('round-counter').style.display = 'block';
  
  stopBackgroundMusic();
  // FIX: Ensure abilities are transferred from the stored lists to the battle interface
  transferAbilities(); 
  loadRound(1); // loadRound(1) will also clear notes at the start of a new game
});

function backToHome() {
  document.getElementById('player1-interface').style.display = 'block';
  document.getElementById('player2-interface').style.display = 'none';
  document.getElementById('match').style.display = 'none';
  document.getElementById('navigation').style.display = 'none';
  document.getElementById('round-counter').style.display = 'none';
  
  // Clear notes and stats state when returning to deck selection
  playerNotes[1] = '';
  playerNotes[2] = '';
  cardStats[1] = { atk: '', def: '', round: '' };
  cardStats[2] = { atk: '', def: '', round: '' };
  
  // Reset HP visually to 11 when returning home
  document.getElementById('hp1').value = 11;
  document.getElementById('hp2').value = 11;

  playBackgroundMusic();
}

function nextRound() {
  if (currentRound < totalRounds) {
    loadRound(currentRound + 1);
  } else {
    // End of game logic
    saveNotes();
    saveCardStats();
    const hp1 = parseInt(document.getElementById('hp1').value);
    const hp2 = parseInt(document.getElementById('hp2').value);
    const title1 = document.getElementById('player1-title').textContent;
    const title2 = document.getElementById('player2-title').textContent;
    
    let winnerMessage = '';
    
    if (hp1 > hp2) {
      winnerMessage = `Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø¹Ø±ÙƒØ©! ğŸ‰ Ø§Ù„ÙØ§Ø¦Ø² Ù‡Ùˆ ${title1} Ø¨Ù€ ${hp1} Ù†Ù‚Ø·Ø© Ù…Ù‚Ø§Ø¨Ù„ ${hp2}.`;
    } else if (hp2 > hp1) {
      winnerMessage = `Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø¹Ø±ÙƒØ©! ğŸ‰ Ø§Ù„ÙØ§Ø¦Ø² Ù‡Ùˆ ${title2} Ø¨Ù€ ${hp2} Ù†Ù‚Ø·Ø© Ù…Ù‚Ø§Ø¨Ù„ ${hp1}.`;
    } else {
      winnerMessage = `Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø¹Ø±ÙƒØ©! ğŸ¤ ØªØ¹Ø§Ø¯Ù„ Ø¨ÙŠÙ† ${title1} Ùˆ ${title2} Ø¨Ù€ ${hp1} Ù†Ù‚Ø·Ø© Ù„ÙƒÙ„ Ù…Ù†Ù‡Ù…Ø§.`;
    }
    
    showStatus(winnerMessage, 'success');
    
    // Show back to home option
    document.getElementById('navigation').innerHTML = `
        <button class="main" onclick="backToHome()">Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
    `;
  }
}

function prevRound() {
  if (currentRound > 1) {
    loadRound(currentRound - 1);
  } else {
    backToHome();
  }
}

function changeHP(player, value) {
  const hpElement = document.getElementById(`hp${player}`);
  let hp = parseInt(hpElement.value) + value;
  if (hp < 0) hp = 0;
  
  hpElement.value = hp;
}

function resetStats(player) {
  const atkElement = document.getElementById(`atk${player}`);
  const defElement = document.getElementById(`def${player}`);
  const roundElement = document.getElementById(`round${player}`);
  
  atkElement.value = '';
  defElement.value = '';
  roundElement.value = '';
  
  // Update global state
  cardStats[player].atk = '';
  cardStats[player].def = '';
  cardStats[player].round = '';
}

function replaceCard(event, player) {
  const file = event.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        const url = e.target.result;
        document.getElementById(`card${player}`).src = url;
        if (player === 1) {
            deck1[currentRound - 1].image = url;
        } else {
            deck2[currentRound - 1].image = url;
        }
    };
    reader.readAsDataURL(file);
  }
}

function createAbilityElement(abilityText) {
  const abilityElement = document.createElement('div');
  abilityElement.className = 'ability';
  abilityElement.textContent = abilityText;
  
  adjustAbilityFontSize(abilityElement, abilityText);
  
  abilityElement.addEventListener('click', function() {
    this.classList.toggle('used');
  });
  return abilityElement;
}

function addAbility(player) {
  const input = document.getElementById(`new-ability${player === 'player1' ? '1' : '2'}`);
  const abilityText = input.value.trim();
  if (abilityText) {
    const container = document.getElementById(`${player}-abilities`);
    container.appendChild(createAbilityElement(abilityText));
    input.value = '';
  }
}

function adjustAbilityFontSize(element, text) {
  const textLength = text.length;
  
  element.classList.remove('long-text', 'very-long-text', 'extremely-long-text');
  
  if (textLength > 120) {
    element.classList.add('extremely-long-text');
  } else if (textLength > 80) {
    element.classList.add('very-long-text');
  } else if (textLength > 50) {
    element.classList.add('long-text');
  }
}

function createNoteShortcuts(player, containerId) {
  const container = document.getElementById(containerId);
  container.innerHTML = '';
  noteShortcuts.forEach(text => {
    const button = document.createElement('button');
    button.className = 'note-shortcut';
    button.textContent = text;
    button.onclick = () => toggleNoteShortcut(player, text, button);
    container.appendChild(button);
  });
}

function toggleNoteShortcut(player, text, element) {
  const notesTextarea = document.getElementById(`notes${player}`);
  let currentText = notesTextarea.value.trim();
  const notesArray = currentText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
  const lineIndex = notesArray.indexOf(text);

  if (element.classList.contains('active')) {
    if (lineIndex !== -1) {
      notesArray.splice(lineIndex, 1);
    }
    element.classList.remove('active', 'green', 'red', 'blue');
  } else {
    notesArray.push(text);
    element.classList.add('active');
    if (text.includes('+')) {
      element.classList.add('green');
    } else if (text.includes('-')) {
      element.classList.add('red');
    } else if (text.includes('NEXT')) {
      element.classList.add('blue');
    }
  }

  notesTextarea.value = notesArray.join('\n');
  playerNotes[player] = notesTextarea.value; // Update global state immediately
}

function showZoomModal(src) {
  const zoomModal = document.getElementById('zoom-modal');
  const transparencyControl = document.querySelector('.transparency-control');
  const transparencySlider = document.getElementById('transparency-slider');

  document.getElementById('zoom-img').src = src;
  zoomModal.style.display = 'flex';
  transparencyControl.style.display = 'flex';
  const initialOpacity = transparencySlider.value / 100;
  zoomModal.style.backgroundColor = `rgba(0, 0, 0, ${initialOpacity})`;
}

document.getElementById('zoom-modal').addEventListener('click', function(event) {
  if (event.target === this) {
    this.style.display = 'none';
    document.querySelector('.transparency-control').style.display = 'none';
  }
});

function showStatus(message, type = 'success') {
  const statusElement = document.getElementById('status-message');
  statusElement.textContent = message;
  statusElement.style.background = type === 'success' ? 'var(--success-color)' : 'var(--primary-color)';
  statusElement.style.display = 'block';
  setTimeout(() => {
    statusElement.style.display = 'none';
  }, 3000);
}

// NOTE: The loadDeckFromData function is no longer needed as we use loadDeckFromUrl directly
// in importPlayerData to update the specific player's deck display.
/* function loadDeckFromData(data) { ... } */

function loadDeckFromUrl(containerId, deckData) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    const fogIsActive = isFogEnabled();
    
    for (let i = 0; i < totalRounds; i++) {
        const cardData = deckData[i] || new Card('images/back.png', null, 'Common');

        const slot = document.createElement('div');
        slot.className = 'round-slot';
        slot.setAttribute('data-round', i + 1);
        slot.setAttribute('data-index', i);
        slot.setAttribute('data-rarity', cardData.rarity || 'Common'); // Set rarity from data

        // Apply fog class to the slot container if fog is active
        if (fogIsActive) {
            slot.classList.add('card-foggy-active');
        }
        
        const span = document.createElement('span');
        span.textContent = i + 1;
        slot.appendChild(span);

        const img = document.createElement('img');
        img.src = cardData.image;
        if (fogIsActive) {
            img.classList.add('card-foggy');
        }
        slot.appendChild(img);

        const cardActions = document.createElement('div');
        cardActions.className = 'card-actions';

        const audioLabel = document.createElement('label');
        audioLabel.textContent = 'ğŸ”Š';
        audioLabel.htmlFor = `card-audio-${containerId.includes('1') ? 1 : 2}-${i}`;

        const audioInput = document.createElement('input');
        audioInput.type = 'file';
        audioInput.id = `card-audio-${containerId.includes('1') ? 1 : 2}-${i}`;
        audioInput.accept = 'audio/*';
        audioInput.style.display = 'none';
        
        audioInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            const player = containerId.includes('1') ? 1 : 2;
            addSoundToCard(i, file, player);
        });

        cardActions.appendChild(audioLabel);
        cardActions.appendChild(audioInput);
        slot.appendChild(cardActions);
        
        container.appendChild(slot);
        
        setupSlotEvents(slot);
    }
}

function transferAbilities() {
  const player1AbilitiesContainer = document.getElementById('player1-abilities');
  const player2AbilitiesContainer = document.getElementById('player2-abilities');

  player1AbilitiesContainer.innerHTML = '';
  player2AbilitiesContainer.innerHTML = '';

  // Use the globally stored ability lists (which were loaded on import or drawn previously)
  deck1Abilities.forEach(abilityText => {
    player1AbilitiesContainer.appendChild(createAbilityElement(abilityText));
  });

  deck2Abilities.forEach(abilityText => {
    player2AbilitiesContainer.appendChild(createAbilityElement(abilityText));
  });
}

function drawPlayerAbilities(player, isFromImport = false) {
  const allAbilities = [
    "Ø§Ù„Ø¯Ø±Ø¹ : ÙŠØ­Ù…ÙŠÙƒ Ù…Ù† Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ùˆ Ø§Ù„Ø®Ø§ØµÙŠØ©", "Ø§Ù„Ø¹Ù„Ø§Ø¬ : ØªØ³ØªØ¹ÙŠØ¯ Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„ØªÙŠ Ø®Ø³Ø±ØªÙ‡Ø§ Ù‡Ø°Ù‡ Ø§Ù„Ø¬ÙˆÙ„Ø©", "Ø¯ÙˆØ¨Ù„ Ø§Ùˆ Ù„Ø§ Ø´ÙŠØ¡ : Ø¥Ù† ÙØ²Øª Ø¨Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© ØªØ²ÙŠØ¯ Ù†Ù‚Ø·Ø© ØµØ­Ø© ÙˆØ¥Ù† Ø®Ø³Ø±Øª ØªÙ†Ù‚Øµ Ù†Ù‚Ø·ØªÙŠÙ†", "Ø§Ø­ÙŠØ§Ø¡ : Ø§Ø¹Ø§Ø¯Ø© Ø¨Ø·Ø§Ù‚Ø© Ø³Ø§Ø¨Ù‚Ø© Ø¨Ù†ØµÙ Ù‚ÙˆØªÙ‡Ø§ Ù…Ø¹ Ø®Ø§ØµÙŠØªÙ‡Ø§", "Ø§Ø­ÙŠØ§Ø¡ Ø®Ø§ØµÙŠØ© : Ø§Ø¹Ø§Ø¯Ø© Ø®Ø§ØµÙŠØ© Ø¨Ø·Ø§Ù‚Ø© Ø³Ø§Ø¨Ù‚Ø©", "Ø§Ù„Ø¥Ù†ÙØ¬Ø§Ø± : Ø¹Ù†Ø¯ Ø§Ù„Ø®Ø³Ø§Ø±Ø© ØªÙ†Ù‚Øµ Ø¬Ù…ÙŠØ¹ Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø§Ø¹Ø¨ Ù†Ù‚Ø·Ø© Ù‡Ø¬ÙˆÙ… Ùˆ Ø¯ÙØ§Ø¹", "ØªØ¨Ø¯ÙŠÙ„ : ØªØµØ¨Ø­ Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø®ØµÙ… Ø¨Ø·Ø§Ù‚ØªÙƒ Ùˆ Ø§Ù„Ø¹ÙƒØ³", "Ø§Ù„ØºØ§Ø¡ Ù‚Ø¯Ø±Ø§Øª Ø§Ù„Ø®ØµÙ… Ù‡Ø°Ù‡ Ø§Ù„Ø¬ÙˆÙ„Ø©", "ØªØ¬Ù…ÙŠØ¯ : ØªÙ„ØºÙ‰ Ø®Ø§ØµÙŠØ© Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø®ØµÙ… Ùˆ Ù‚Ø¯Ø±Ø§ØªÙ‡", "Ø§Ù„Ø¥Ù†ØªØ­Ø§Ø± : Ø¹Ù†Ø¯ Ø§Ù„Ø®Ø³Ø§Ø±Ø© ÙŠÙ…ÙˆØª Ø§Ù„Ø®ØµÙ… Ù…Ø¹Ùƒ", "ØªÙ‚ÙˆÙŠØ© : Ù…Ø¸Ø§Ø¹ÙØ© Ù†Ù‚Ø§Ø· Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©", "ØªØ¶Ø¹ÙŠÙ : ØªÙÙ‚Ø¯ Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø®ØµÙ… Ù†ØµÙ Ø·Ø§Ù‚Ø§ØªÙ‡Ø§", "Ù†Ø³Ø® Ø§Ù„Ø®Ø§ØµÙŠØ© : ØªÙ†Ø³Ø® Ø®Ø§ØµÙŠØ© Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø®ØµÙ… Ø§Ù„Ø­Ø§Ù„ÙŠØ©", "Ù†Ø³Ø® Ø§Ù„Ù‚Ø¯Ø±Ø© : ØªÙ†Ø³Ø® Ø§Ø­Ø¯ Ù‚Ø¯Ø±Ø§Øª Ø§Ù„Ø®ØµÙ…", "Ø³Ø±Ù‚Ø© : ØªØ³Ø±Ù‚ Ø®Ø§ØµÙŠØ© Ø§Ù„Ø®ØµÙ… Ø§Ùˆ Ø§Ø­Ø¯ Ù‚Ø¯Ø±Ø§ØªÙ‡", "Ù…Ø³Ø­ : Ù…Ø³Ø­ Ø§Ø­Ø¯ Ù‚Ø¯Ø±Ø§Øª Ø§Ù„Ø®ØµÙ… Ù…Ù† Ø¥Ø®ØªÙŠØ§Ø±Ùƒ", "Ø§Ù„Ù‚Ù†Øµ : Ø¥Ø®ØªØ§Ø± Ø¬ÙˆÙ„Ø© Ù…Ø¹ÙŠÙ†Ø© Ù„ØªÙÙˆØ² Ø¨Ù‡Ø§ ", "Ù‡Ø§ÙƒÙŠ : ØªÙˆÙ‚Ø¹ Ù‡Ø¬ÙˆÙ… Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø®ØµÙ… Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© Ù„ØªØ²ÙŠØ¯ Ù†Ù‚Ø·Ø© ØµØ­Ø© ", "Ø³Ø±Ù‚Ø© : Ø³Ø±Ù‚Ø© Ø¨ÙˆÙØ§Øª Ø§Ù„Ø®ØµÙ…", "Ø§Ù„Ø®ØªÙ… : Ø§Ø®ØªÙ… Ù‚Ø¯Ø±Ø© Ù„Ù„Ø®ØµÙ… 3 Ø¬ÙˆÙ„Ø§Øª Ù‚Ø§Ø¯Ù…Ø© ", "Ø§Ù„Ø§Ù†ØªØ­Ø§Ø± : Ù…Ø¹ Ø§Ù„Ø®Ø³Ø§Ø±Ø© ÙŠÙ†Ù‚Øµ Ø§Ù„Ø®ØµÙ… Ù…Ø¹Ùƒ", "Ù…Ø³Ø­ : Ù…Ø³Ø­ Ø¨ÙˆÙØ§Øª Ø§Ù„Ø®ØµÙ… ÙÙ‚Ø· ", "ØªÙ†Ø¸ÙŠÙ : Ù…Ø³Ø­ ÙƒÙ„ Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª Ù„Ùƒ Ùˆ Ø§Ù„Ø®ØµÙ…", "Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚ : Ù†Ù‚Ø§Ø· Ø¯ÙØ§Ø¹ Ø§Ù„Ø®ØµÙ… 0 ", "Ø§Ù„Ø³Ù„Ø¨ : ØªØ§Ø®Ø¯ Ø¨ÙˆÙ Ù…Ù† Ø¨ÙˆÙØ§Øª Ø§Ù„Ø®ØµÙ… ", "Ø³ÙƒØ¨ : ØªØ³ÙƒØ¨ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø¯ÙˆÙ† Ø¥Ø­ØªØ³Ø§Ø¨ Ø´ÙŠØ¡", "Ù„Ø§ÙŠÙ Ø³ØªÙŠÙ„ : Ù…Ø¹ Ø§Ù„ÙÙˆØ² ØªØ²ÙŠØ¯ Ù†Ù‚Ø·Ø© ØµØ­Ø© ","Ø§Ù„Ø¬Ø´Ø¹ : Ø¹Ù†Ø¯ Ø§Ù„ÙÙˆØ² ØªØ²ÙŠØ¯ ÙƒÙ„ Ø§Ù„ÙƒØ±ÙˆØª Ø¹Ù†Ø¯Ùƒ 1 Ù‡Ø¬ÙˆÙ…","Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ : Ø§Ø¹Ø§Ø¯Ø© ÙƒØ±Øª Ù„Ùƒ Ø¨ÙƒÙ„ Ù‚ÙˆØªÙ‡ Ø¨Ø¯ÙˆÙ† Ø®Ø§ØµÙŠØ©","Ø§Ù„Ø­Ù…Ø§ÙŠØ© : Ù„Ø§ ØªÙ†Ù‚Øµ Ø§ÙŠ Ù†Ù‚Ø·Ø© ØµØ­Ø© Ù‡Ø°Ù‡ Ø§Ù„Ø¬ÙˆÙ„Ø© ","Ø¨ÙˆØ³Øª : ØªØ¶Ø§Ø¹Ù Ù†Ù‚Ø§Ø· Ù‡Ø¬ÙˆÙ…Ùƒ Ø§Ùˆ Ø¯ÙØ§Ø¹Ùƒ ","Ø§Ù„Ù‡Ø§ÙˆÙŠØ© : Ù†Ù‚Ø§Ø· Ù‡Ø¬ÙˆÙ… Ø§Ù„Ø®ØµÙ… 0","ØªØºÙŠÙŠØ±: ØªØºÙŠØ± Ù‚Ø¯Ø±Ø© Ù„Ùƒ Ø¨Ù‚Ø¯Ø±Ø© Ù„Ø¯Ù‰ Ø§Ù„Ø®ØµÙ… Ùˆ Ø§Ù„Ø¹ÙƒØ³","Ø¹ÙƒØ³ : ØªØ¹ÙƒØ³ Ø·Ø§Ù‚Ø§Øª Ø¨Ø·Ø§Ù‚ØªÙƒ Ù…Ø¹ Ø§Ù„Ø®ØµÙ…","ÙƒÙˆÙ†ØªØ± : ØªØ·Ø¨Ù‚ Ø®Ø§ØµÙŠØ© Ø§Ù„Ø®ØµÙ… Ø¹Ù„ÙŠÙ‡ Ø¨Ø´ÙƒÙ„ Ø³Ù„Ø¨ÙŠ","Ø¯Ù…Ø¬ : Ø¯Ù…Ø¬ Ù†ØµÙ Ø·Ø§Ù‚Ø§Øª Ø¨Ø·Ø§Ù‚ØªÙƒ Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù…Ø¹ Ù†ØµÙ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©","ØªØ±ÙƒÙŠØ¨ : ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø®Ø¯ Ù‡Ø¬ÙˆÙ… Ø§Ùˆ Ø¯ÙØ§Ø¹ Ø¨Ø·Ø§Ù‚ØªÙƒ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ø§Ù„Ø§Ù†","ØªØ®ØµØµ : ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ± ÙØ¦Ø© Ø¨Ø·Ø§Ù‚Ø§ØªÙƒ Ø§Ù„Ù‰ Ù…Ø§ ØªØ±ÙŠØ¯"
  ];

  let drawnAbilities = [];
  
  if (isFromImport) {
    // If from import, use the already loaded global lists
    drawnAbilities = player === 1 ? deck1Abilities : deck2Abilities;
  } else {
    // If drawing fresh abilities
    const otherPlayerAbilities = player === 1 ? deck2Abilities : deck1Abilities;
    const availableAbilities = allAbilities.filter(ability => !otherPlayerAbilities.includes(ability));

    if (availableAbilities.length < 3) {
        showStatus('Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚Ø¯Ø±Ø§Øª ÙƒØ§ÙÙŠØ© Ù…ØªØ§Ø­Ø© Ø¨Ø¯ÙˆÙ† ØªÙƒØ±Ø§Ø±!', 'error');
        return;
    }
    
    const shuffledAbilities = [...availableAbilities].sort(() => 0.5 - Math.random());
    drawnAbilities = shuffledAbilities.slice(0, 3);
  
    if (player === 1) {
      deck1Abilities = drawnAbilities;
    } else {
      deck2Abilities = drawnAbilities;
    }
  }

  const container = document.getElementById(`deck${player}-abilities-display`);
  container.innerHTML = '';
  
  drawnAbilities.forEach(abilityText => {
    const p = document.createElement('p');
    p.textContent = `â€¢ ${abilityText}`;
    p.style.fontSize = '14px';
    p.style.lineHeight = '1.5';
    container.appendChild(p);
  });
  
  if (!isFromImport) {
     showStatus(`ØªÙ… Ø³Ø­Ø¨ ${drawnAbilities.length} Ù‚Ø¯Ø±Ø§Øª Ù„Ù„Ø§Ø¹Ø¨ ${player} Ø¨Ù†Ø¬Ø§Ø­!`);
  }
}

function handleTextDirection(textarea) {
    // FIX: Set direction to LTR permanently for English/number notes
    textarea.style.direction = 'ltr';
    textarea.style.textAlign = 'left';
    
    // New: Listen to input to save state
    textarea.addEventListener('input', (e) => {
        const player = e.target.id.includes('1') ? 1 : 2;
        playerNotes[player] = e.target.value;
        highlightShortcuts(player); // Re-highlight on input
    });
}

// NEW: Add event listeners to save stats when they change
function addStatsEventListeners() {
    ['atk1', 'def1', 'round1', 'atk2', 'def2', 'round2'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener('input', () => {
                saveCardStats();
            });
        }
    });
}

// =======================================================
// NEW: INDIVIDUAL EXPORT/IMPORT FUNCTIONS
// =======================================================

// NEW: Split export function for individual players
function exportPlayerData(player) {
    const titleId = `title${player}`;
    const deck = player === 1 ? deck1 : deck2;
    const abilities = player === 1 ? deck1Abilities : deck2Abilities;

    if (deck.filter(card => card.image && card.image !== 'images/back.png').length === 0) {
        showStatus(`Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨Ø·Ø§Ù‚Ø§Øª Ù„Ø­ÙØ¸Ù‡Ø§ Ù„Ù„Ø§Ø¹Ø¨ ${player}!`, 'error');
        return;
    }

    const playerData = {
        player: player,
        title: document.getElementById(titleId).value || `Ø§Ù„Ù„Ø§Ø¹Ø¨ ${player}`,
        deck: deck,
        abilities: abilities,
        // Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª ÙˆØ­Ø§Ù„Ø© Ø§Ù„Ù€ HP ÙˆØ§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        playerNotes: player === 1 ? playerNotes[1] : playerNotes[2],
        cardStats: cardStats[player],
        hp: document.getElementById(`hp${player}`).value // Ø­ÙØ¸ HP Ø§Ù„Ø­Ø§Ù„ÙŠØ©
    };

    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(playerData, null, 2));
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", `naruto-cards-player-${player}.json`);
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
    showStatus(`ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù„Ø§Ø¹Ø¨ ${player} Ø¨Ù†Ø¬Ø§Ø­!`);
}

// NEW: Split import function for individual players
function importPlayerData(event, player) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ù„Ù ÙŠØ¹ÙˆØ¯ Ù„Ù†ÙØ³ Ø§Ù„Ù„Ø§Ø¹Ø¨
            if (data.player !== player) {
                showStatus(`Ø®Ø·Ø£: Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù Ù„Ù„Ø§Ø¹Ø¨ ${data.player} ÙˆÙ„ÙŠØ³ Ù„Ù„Ø§Ø¹Ø¨ ${player}.`, 'error');
                document.getElementById(`import-file-${player}`).value = ''; 
                return;
            }

            const deckToLoad = data.deck || [];
            const abilitiesToLoad = data.abilities || [];
            
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©
            if (player === 1) {
                deck1 = deckToLoad;
                deck1Abilities = abilitiesToLoad;
                playerNotes[1] = data.playerNotes || '';
                cardStats[1] = data.cardStats || { atk: '', def: '', round: '' };
            } else {
                deck2 = deckToLoad;
                deck2Abilities = abilitiesToLoad;
                playerNotes[2] = data.playerNotes || '';
                cardStats[2] = data.cardStats || { atk: '', def: '', round: '' };
            }
            
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
            document.getElementById(`title${player}`).value = data.title || `Ø§Ù„Ù„Ø§Ø¹Ø¨ ${player}`;
            if (data.hp) {
                document.getElementById(`hp${player}`).value = data.hp; 
            }
            
            // Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù… Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª ÙÙŠ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯
            loadDeckFromUrl(`rounds-container${player}`, deckToLoad);
            // Ø¥Ø¹Ø§Ø¯Ø© Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø¯Ø±Ø§Øª ÙÙŠ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯
            drawPlayerAbilities(player, true); 

            showStatus(`ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù„Ø§Ø¹Ø¨ ${player} Ø¨Ù†Ø¬Ø§Ø­!`);

        } catch (error) {
            console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù…Ù„Ù:', error);
            showStatus('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù…Ù„Ù. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†Ù‡ Ù…Ù„Ù ØµØ§Ù„Ø­.', 'error');
        }
    };
    reader.readAsText(file);
}

// NOTE: OLD exportGameData and importGameData functions REMOVED/IGNORED

function toggleFogEffect() {
  const allCards = document.querySelectorAll('#match .card img, .round-slot img');
  const isCurrentlyFoggy = isFogEnabled();
  
  allCards.forEach(img => {
    const shouldBeFoggy = !isCurrentlyFoggy;
    img.classList.toggle('card-foggy', shouldBeFoggy);
    
    // Hide/Show rarity bar based on fog state for .round-slot
    const slot = img.closest('.round-slot');
    if (slot) {
        slot.classList.toggle('card-foggy-active', shouldBeFoggy);
    }
    
    // Hide/Show rarity bar based on fog state for .card
    const card = img.closest('.card');
    if (card) {
        card.classList.toggle('card-foggy-active', shouldBeFoggy);
    }
  });

  // Re-apply visibility logic for current cards to ensure rarity bar disappears
  const card1Element = document.getElementById('player1-card');
  const card2Element = document.getElementById('player2-card');
  
  if (card1Element) card1Element.classList.toggle('card-foggy-active', !isCurrentlyFoggy);
  if (card2Element) card2Element.classList.toggle('card-foggy-active', !isCurrentlyFoggy);
  
  showStatus(!isCurrentlyFoggy ? 'ØªÙ… ØªÙØ¹ÙŠÙ„ Ø¶Ø¨Ø§Ø¨ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª' : 'ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¶Ø¨Ø§Ø¨ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª');
}

function toggleFullScreen() {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      console.log(`Ø®Ø·Ø£ ÙÙŠ ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø©: ${err.message}`);
    });
  } else {
    document.exitFullscreen();
  }
}

// =======================================================
// RANDOM CARD PULL & RARITY VISUALS
// =======================================================

const CARD_NAMES = {
    Common: [
        'Akamaru.jpeg', 'Anko.jpeg', 'Araya.jpeg', 'Asuma.jpeg', 'Baki.jpeg', 'Boruto Uzumaki.jpeg', 'Cho tcho.jpeg', 'Choper.jpeg', 'Chouji 2.jpeg', 'Dan.jpeg', 'Denki.jpeg', 'Dosu.jpeg', 'Ebisu.jpeg', 'Gara.jpeg', 'Gato.jpeg', 'Haku.jpeg', 'Hayate.jpeg', 'Hima.jpeg', 'Himawari.jpeg', 'Hinata.jpeg', 'Ibiki.jpeg', 'Inari.jpeg', 'Ino yamanaka.jpeg', 'Inojin.jpeg', 'Iruka.jpeg', 'Itachi Uchiha.jpeg', 'Iwabe.jpeg', 'Izumo.jpeg', 'Jiraya.jpeg', 'Jirobo.jpeg', 'Kabuto.jpeg', 'Kakashi copie.jpeg', 'Kankuro.jpeg', 'Karura.jpeg', 'Kiba.jpeg', 'Kidomaro.jpeg', 'Kimimaro.jpeg', 'Kagumaro.jpeg', 'Kisame.jpeg', 'Konoha.jpeg', 'Konohamaru.jpeg', 'Kotetsu.jpeg', 'Kurenai.jpeg', 'Kurio Hako.jpeg', 'Metal Lee.jpeg', 'Might guy.jpeg', 'Mitsuki.jpeg', 'Mizuki.jpeg', 'Mugino.jpeg', 'Namida.jpeg', 'Naruto raseyubi.jpeg', 'Ramen girl.jpeg', 'Narutogan.jpeg', 'Neji hyuga.jpeg', 'Oruchimaro.jpeg', 'Naruto.jpeg', 'Narutokyubi.jpeg', 'Ramen.jpeg', 'Rock lee.jpeg', 'Sakon _ ukon.jpeg', 'Sakura trash.jpeg', 'Sarada Uchiha.jpeg', 'Sarutobi Hiruzen.jpeg', 'Sasuke Uchiha _66d183.jpeg', 'Sasuke3fn.jpeg', 'Sasuke.jpeg', 'Sasukechunin.jpeg', 'Sasuke Uchiha 3.jpeg', 'Shikadai Nara.jpeg', 'Shikanara.jpeg', 'Shinki.jpeg', 'Shino Aborami.jpeg', 'Shino.jpeg', 'Sumire.jpeg', 'Tayuya.jpeg', 'Tazuna.jpeg', 'Temarishika.jpeg', 'Temari.jpeg', 'Ten ten.jpeg', 'Tshuzuni.jpeg', 'Tsubaki.jpeg', 'Tsunade.jpeg', 'Wasabi.jpeg', 'Udon.jpeg', 'Zabuza.jpeg', '_Hako.jpeg'
    ],
    Rare: [
        'Amano Ringo.jpeg', 'Ashura Otsutsuki.jpeg', 'Chiyo Shippuden.jpeg', 'Chouji Shippuden.jpeg', 'Chukaku.jpeg', 'Danzo izanagi.jpeg', 'Danzo anbu.jpeg', 'Darui.jpeg', 'Deidara.jpeg', 'Foo Yamanaka.jpeg', 'Fugako Uchiha.jpeg', 'Fuguki.jpeg', 'Fuu.jpeg', 'Hamura Otsutsuki.jpeg', 'Gara Kazekage.jpeg', 'Han.jpeg', 'HANZO.jpeg', 'Hashirama Senju.jpeg', 'Hinata Shippuden.jpeg', 'Indra Otsutsuki.jpeg', 'Ino Shipp.jpeg', 'Itachi susano.jpeg', 'Itachi yata.jpeg', 'Jinbachi Munashi.jpeg', 'Jinin Akebino.jpeg', 'Jirayadie.jpeg', 'Juzo.jpeg', 'Kaguyamini.jpeg', 'Kakashi kamui.jpeg', 'Kakozo.jpeg', 'Kakuzo5.jpeg', 'Hiddan (1).jpeg', 'Kankoro Shippuden.jpeg', 'Karen Uzumaki.jpeg', 'Kiba Shippuden.jpeg', 'Gyuki.jpeg', 'Killerap.jpeg', 'Killer Bee.jpeg', 'Kinkaku -Ginkaku.jpeg', 'Konohashipp.jpeg', 'Kushimaru.jpeg', 'Kushina Uzumaki.jpeg', 'Madara edo.jpeg', 'Madara life.jpeg', 'Mangetsu.jpeg', 'Mifune.jpeg', 'Mei Mizokage.jpeg', 'Mightduy.jpeg', 'Minato Edo.jpeg', 'Minato kcm1.jpeg', 'Minato Namikaze.jpeg', 'Mu.jpeg', 'Nagato-Pain.jpeg', 'Nagato Uzumaki.jpeg', 'Naruto back.jpeg', 'Nchakera.jpeg', 'Naruto sagerasen.jpeg', 'Naruto sagemode.jpeg', 'Naruto kcm1rase.jpeg', 'Naruto kcm2.jpeg', 'Naruto shurekin.jpeg', 'Neji Shippuden.jpeg', 'Sae Shippuden.jpeg', 'Sakumo Hatake.jpeg', 'Sakura chanaru.jpeg', 'Sakura health.jpeg', 'Sakura byakugo.jpeg', 'Sakura Haruno.jpeg', 'Sasori aka.jpeg', 'Sasori.jpeg', 'Sasuke Akatsuki.jpeg', 'Sasuke kiren.jpeg', 'Sasuke fuijin.jpeg', 'Sasuke mangekyo.jpeg', 'Sasuke susano.jpeg', 'Sasuke Shidori.jpeg', 'Sasuke Shippuden.jpeg', 'Shikamaru Shippuden.jpeg', 'Shino Shippuden.jpeg', 'Shiriko.jpeg', 'Suigetsu.jpeg', 'Temari Shippuden.jpeg', 'Tenten Shippuden.jpeg', 'Tobi.jpeg', 'Tobirama edo.jpeg', 'Tobirama Senju.jpeg', 'Torune.jpeg', 'Tsunade Senju.jpeg', 'Yagura.jpeg', 'Yamato.jpeg', 'Yugito Nii.jpeg', 'Shisui susano.jpeg', 'Shisui Uchiha.jpeg', 'Zetsu Akatsuki.jpeg','Yahiko.jpeg','Orufuin.jpeg','Ouruchimaro_6a036e.jpeg','Onoki.jpeg','Obito Kyubi.jpeg','Obito Ginin.jpeg','Otakata.jpeg','Reikage A 4.jpeg','A.jpeg','Roshi.jpeg','Rock shipp.jpeg','Rasa.jpeg','Obito - Zetsu.jpeg','JUGO.jpeg','Sarutobi Edo Tensie.jpeg',
    ],
    Legendary: [
        'ALL FOR ONE.jpeg', 'Aizen Sosuke (1).jpeg', 'All Might.jpeg', 'Asta Black Clover.jpeg', 'Ban Natatsu No Taizai (1).jpeg', 'Chrolo Lucifer .jpeg', 'Crow Zetsu.jpeg', 'Elizabeth .jpeg', 'Eri Tchan.jpeg', 'Escanor .jpeg', 'Getou.jpeg', 'Gojo satoru _79ea8b.jpeg', 'Hagorumo Otsutsuki.jpeg', 'Hisoka.jpeg', 'Ishigami Senku.jpeg', 'Itachi edo.jpeg', 'Jubito.jpeg', 'Kabuto Shippuden .jpeg', 'Kaguya Otsutsuki.jpeg', 'Kaido.jpeg', 'Kakashi hatake .jpeg', 'Limilion (1).jpeg', 'Madara War.jpeg', 'Madara susano.jpeg', 'Madara perfect.jpeg', 'Madara early.jpeg', 'Madara rekudo.jpeg', 'Marshal D Tetch (1).jpeg', 'Sate.jpeg', 'Mightguy.jpeg', 'Mihawk.jpeg', 'Monkey D Luffy.jpeg', 'Musachi.jpeg', 'Nagato.jpeg', 'Naruto kurama.jpeg', 'Naruto rekudo.jpeg', 'Naruto baryon.jpeg', 'Sasuke last.jpeg', 'Sanji Vinsmoke.jpeg', 'Sasuke Uchiha _5182c5.jpeg', 'Sukuna.jpeg', 'Sung Jin woo.jpeg', 'Todoroki Shoto.jpeg', 'Trafalgar D Water Law_b84892.jpeg', 'Uchiha obito (1).jpeg', 'Uchiha obito.jpeg', 'Yagami Light.jpeg', 'Yami Sekuhiro.jpeg', 'Yuno Black Clover.jpeg', 'Zenin Touji.jpeg'
    ]
};

const CARD_CONFIG = {
    baseUrl: 'https://raw.githubusercontent.com/tobiok090-dotcom/naruto-card-game/main/naruto-card-game/Cards/',
    pullCounts: {
        Legendary: 1, 
        Rare: 5, 
        Common: 5
    }
};

function getCardName(type, index) {
    return (CARD_NAMES[type] && CARD_NAMES[type][index - 1]) ? CARD_NAMES[type][index - 1] : null;
}

function drawRandomCards(cardType, count, excludeSet) {
    const drawnCards = [];
    const availableIndices = [];
    
    for (let i = 1; i <= CARD_NAMES[cardType].length; i++) {
        const cardKey = `${cardType}_${i}`;
        if (!excludeSet.has(cardKey)) {
             availableIndices.push(i);
        }
    }
    
    if (availableIndices.length < count) {
        count = availableIndices.length;
    }

    for (let i = 0; i < count && availableIndices.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * availableIndices.length);
        const cardIndex = availableIndices[randomIndex];
        
        const cardName = getCardName(cardType, cardIndex);
        if (!cardName) continue;
        
        const cardKey = `${cardType}_${cardIndex}`;
        
        drawnCards.push({
            type: cardType,
            name: cardName.replace('.jpeg', ''),
            url: `${CARD_CONFIG.baseUrl}${cardType}/${cardName}`,
            id: cardKey,
            index: cardIndex
        });
        
        excludeSet.add(cardKey); 
        availableIndices.splice(randomIndex, 1);
    }
    
    return drawnCards;
}

function drawPlayerDeck(player) {
    const playerCards = [];
    
    if (player === 1) {
        globalDrawnCardsSet.clear();
    }
    
    try {
        // Legendary (1)
        playerCards.push(...drawRandomCards('Legendary', CARD_CONFIG.pullCounts.Legendary, globalDrawnCardsSet));
        // Rare (5)
        playerCards.push(...drawRandomCards('Rare', CARD_CONFIG.pullCounts.Rare, globalDrawnCardsSet));
        // Common (5)
        playerCards.push(...drawRandomCards('Common', CARD_CONFIG.pullCounts.Common, globalDrawnCardsSet));
        
    } catch (error) {
        console.error('Ø®Ø·Ø£ ÙÙŠ Ø³Ø­Ø¨ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª:', error);
    }
    
    return playerCards;
}

function loadDrawnCards(cards, containerId, deck) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    const fogIsActive = isFogEnabled();
    
    // Sort cards: Legendary first (1), then Rare (5), then Common (5)
    cards.sort((a, b) => {
        const order = { 'Legendary': 1, 'Rare': 2, 'Common': 3 };
        return order[a.type] - order[b.type];
    });
    
    cards.forEach((card, index) => {
        const slot = document.createElement('div');
        slot.className = 'round-slot';
        slot.setAttribute('data-round', index + 1);
        slot.setAttribute('data-index', index);
        slot.setAttribute('data-rarity', card.type); // New: Set rarity attribute

        if (fogIsActive) {
            slot.classList.add('card-foggy-active');
        }

        const span = document.createElement('span');
        span.textContent = index + 1;
        slot.appendChild(span);

        const img = document.createElement('img');
        img.src = card.url;
        img.onerror = function() {
            this.src = 'images/back.png';
            console.error('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©:', card.url);
        };
        slot.appendChild(img);
        
        if (fogIsActive) {
            img.classList.add('card-foggy');
        }

        const cardActions = document.createElement('div');
        cardActions.className = 'card-actions';

        const audioLabel = document.createElement('label');
        audioLabel.textContent = 'ğŸ”Š';
        audioLabel.htmlFor = `card-audio-${containerId.includes('1') ? 1 : 2}-${index}`;

        const audioInput = document.createElement('input');
        audioInput.type = 'file';
        audioInput.id = `card-audio-${containerId.includes('1') ? 1 : 2}-${index}`;
        audioInput.accept = 'audio/*';
        audioInput.style.display = 'none';
        
        audioInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            const player = containerId.includes('1') ? 1 : 2;
            addSoundToCard(index, file, player);
        });

        cardActions.appendChild(audioLabel);
        cardActions.appendChild(audioInput);
        slot.appendChild(cardActions);
        
        container.appendChild(slot);
        
        deck[index] = new Card(card.url, null, card.type); // Save rarity
        
        setupSlotEvents(slot);
    });
}

function drawRandomDeck(player) {
    // Ensure both decks are initialized before drawing
    if (deck1.length === 0 || deck2.length === 0) {
        createRoundSlots('rounds-container1', deck1);
        createRoundSlots('rounds-container2', deck2);
    }
    
    const cards = drawPlayerDeck(player);
    const containerId = `rounds-container${player}`;
    const deck = player === 1 ? deck1 : deck2;
    
    // Clear the deck array and re-initialize with default cards before loading new ones
    for (let i = 0; i < totalRounds; i++) {
        deck[i] = new Card('images/back.png', null, 'Common');
    }
    
    loadDrawnCards(cards, containerId, deck);
    
    console.log(`ØªÙ… Ø³Ø­Ø¨ ${cards.length} Ø¨Ø·Ø§Ù‚Ø© Ù„Ù„Ø§Ø¹Ø¨ ${player}. Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ù…Ø³Ø­ÙˆØ¨Ø© ÙƒÙ„ÙŠØ§Ù‹: ${globalDrawnCardsSet.size}`);
    showStatus(`ØªÙ… Ø³Ø­Ø¨ ${cards.length} Ø¨Ø·Ø§Ù‚Ø© Ù„Ù„Ø§Ø¹Ø¨ ${player} Ø¨Ù†Ø¬Ø§Ø­!`);
}

// =======================================================
// INITIALIZATION
// =======================================================

document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('login-btn').addEventListener('click', validateLogin);
    
    // Initialize decks with default cards
    createRoundSlots('rounds-container1', deck1);
    createRoundSlots('rounds-container2', deck2);

    createNoteShortcuts(1, 'shortcuts1');
    createNoteShortcuts(2, 'shortcuts2');

    // Apply the function to set LTR and add listener for continuous state saving
    handleTextDirection(document.getElementById('notes1'));
    handleTextDirection(document.getElementById('notes2'));
    
    // NEW: Add event listeners for stats inputs
    addStatsEventListeners();
    
    initAudioSystem();
    
    const transparencySlider = document.getElementById('transparency-slider');
    const zoomModal = document.getElementById('zoom-modal');
    
    transparencySlider.addEventListener('input', function() {
        const opacity = this.value / 100;
        zoomModal.style.backgroundColor = `rgba(0, 0, 0, ${opacity})`;
    });

    document.getElementById('player1-card').addEventListener('dblclick', () => {
        const cardImg = document.getElementById('card1');
        if (cardImg.src) {
            showZoomModal(cardImg.src);
        }
    });

    document.getElementById('player2-card').addEventListener('dblclick', () => {
        const cardImg = document.getElementById('card2');
        if (cardImg.src) {
            showZoomModal(cardImg.src);
        }
    });

    document.getElementById('previous-card1').parentElement.addEventListener('dblclick', (e) => {
        const img = e.target;
        if (img.src) {
            showZoomModal(img.src);
        }
    });
    
    document.getElementById('previous-card2').parentElement.addEventListener('dblclick', (e) => {
        const img = e.target;
        if (img.src) {
            showZoomModal(img.src);
        }
    });
    
    document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);

    document.addEventListener('fullscreenchange', () => {
      const icon = document.getElementById('fullscreen-icon');
      if (document.fullscreenElement) {
        icon.textContent = 'âŒŒ'; 
      } else {
        icon.textContent = 'â›¶';
      }
    });
});
</script>
</body>
</html>

